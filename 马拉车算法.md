# 马拉车算法

## 问题：请找出字符串 `bcbabcc` 最长回文子串的长度

## 暴力

![alt text](253c035d48edcb8ce061be287107250.jpg)

用 `i` 指示最前面的下标，用 `j` 指示下一个与 `i` 相同的字符索引，当 `arr[i] = arr[j]` 时，将 `i` 和 `j` 向中间靠拢。

## 向中间靠拢

![alt text](90a49438d6e602757717252ddd61a6c.jpg)

由于奇偶不同，所以采取了一种很巧妙的方法：  
a#b#b#a?  
(中间填充同一种特殊字符，两边填充不同的特殊字符)  

但是我们想想，真的充分利用回文串的对称性质了吗？  
答案是没有。  

我们可以再来考虑下 `cbabc` 这个字符串：  
^c#b#a#b#c?  
它向两边各扩展了 5 次，则它的回文串长度一定是 5。  
我们可以来证明一下：  
假设它扩展了 `len` 次，扩展之后长度为 `2*len+1`，  
其中特殊字符为 `len+1`，那么回文长度为 `len`，证毕。

我们可以想象求一个中间数的回文长度是在种蘑菇，用 `p` 数组来记录蘑菇的半径：  
^b#c#b#a#b#c#c?  
p:    0020105  
![alt text](21c5743b4b3c0ab9d9a7317b7e7afb3.jpg)

我们能不能不用计算，计算下面几个元素的回文串长度呢？  
利用回文串的对称性，我们可以很快得到：  
- `#` 的长度为 0  
- `b` 的长度为 1  
- `#` 的长度为 0  
- `c` 的长度为 2（绝对是 2，不需要考虑出去的部分，否则 `a` 蘑菇的半径还会更大）  
- `#` 的长度为 0  

## 马拉车算法

就是利用了上述这种思想。  
- 用一个数组 `p` 记录每个蘑菇的半径大小  
- 用两个变量分别记录能伸展到最右边的蘑菇半径，以及对应的蘑菇伞柄  
- 遍历字符串，找出能计算的蘑菇半径  
- 运用中间扩展算法计算新的蘑菇半径  
- 更新第二步的那两个变量
